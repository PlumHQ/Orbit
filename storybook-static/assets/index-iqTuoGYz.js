import{r as i,a as A}from"./index-DpTt3J-R.js";import{b as v}from"./index-Ca3VPhni.js";import{r as M}from"./index-D9ZhQrDp.js";import{c as R}from"./index-B6TRxRi1.js";import{j as h}from"./jsx-runtime-BjG_zV1W.js";import{u as E}from"./index-B5ODnmFs.js";function k(t,e,{checkForDefaultPrevented:n=!0}={}){return function(r){if(t==null||t(r),n===!1||!r.defaultPrevented)return e==null?void 0:e(r)}}var O=A[" useId ".trim().toString()]||(()=>{}),g=0;function V(t){const[e,n]=i.useState(O());return v(()=>{n(o=>o??String(g++))},[t]),e?`radix-${e}`:""}var I=A[" useInsertionEffect ".trim().toString()]||v;function q({prop:t,defaultProp:e,onChange:n=()=>{},caller:o}){const[r,s,f]=y({defaultProp:e,onChange:n}),u=t!==void 0,m=u?t:r;{const a=i.useRef(t!==void 0);i.useEffect(()=>{const d=a.current;d!==u&&console.warn(`${o} is changing from ${d?"controlled":"uncontrolled"} to ${u?"controlled":"uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),a.current=u},[u,o])}const c=i.useCallback(a=>{var d;if(u){const l=T(a)?a(t):a;l!==t&&((d=f.current)==null||d.call(f,l))}else s(a)},[u,t,s,f]);return[m,c]}function y({defaultProp:t,onChange:e}){const[n,o]=i.useState(t),r=i.useRef(n),s=i.useRef(e);return I(()=>{s.current=e},[e]),i.useEffect(()=>{var f;r.current!==n&&((f=s.current)==null||f.call(s,n),r.current=n)},[n,r]),[n,o,s]}function T(t){return typeof t=="function"}var U=["a","button","div","form","h2","h3","img","input","label","li","nav","ol","p","select","span","svg","ul"],z=U.reduce((t,e)=>{const n=R(`Primitive.${e}`),o=i.forwardRef((r,s)=>{const{asChild:f,...u}=r,m=f?n:e;return typeof window<"u"&&(window[Symbol.for("radix-ui")]=!0),h.jsx(m,{...u,ref:s})});return o.displayName=`Primitive.${e}`,{...t,[e]:o}},{});function B(t,e){t&&M.flushSync(()=>t.dispatchEvent(e))}function C(t,e){return i.useReducer((n,o)=>e[n][o]??n,t)}var b=t=>{const{present:e,children:n}=t,o=D(e),r=typeof n=="function"?n({present:o.isPresent}):i.Children.only(n),s=E(o.ref,x(r));return typeof n=="function"||o.isPresent?i.cloneElement(r,{ref:s}):null};b.displayName="Presence";function D(t){const[e,n]=i.useState(),o=i.useRef(null),r=i.useRef(t),s=i.useRef("none"),f=t?"mounted":"unmounted",[u,m]=C(f,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}});return i.useEffect(()=>{const c=N(o.current);s.current=u==="mounted"?c:"none"},[u]),v(()=>{const c=o.current,a=r.current;if(a!==t){const l=s.current,p=N(c);t?m("MOUNT"):p==="none"||(c==null?void 0:c.display)==="none"?m("UNMOUNT"):m(a&&l!==p?"ANIMATION_OUT":"UNMOUNT"),r.current=t}},[t,m]),v(()=>{if(e){let c;const a=e.ownerDocument.defaultView??window,d=p=>{const w=N(o.current).includes(p.animationName);if(p.target===e&&w&&(m("ANIMATION_END"),!r.current)){const P=e.style.animationFillMode;e.style.animationFillMode="forwards",c=a.setTimeout(()=>{e.style.animationFillMode==="forwards"&&(e.style.animationFillMode=P)})}},l=p=>{p.target===e&&(s.current=N(o.current))};return e.addEventListener("animationstart",l),e.addEventListener("animationcancel",d),e.addEventListener("animationend",d),()=>{a.clearTimeout(c),e.removeEventListener("animationstart",l),e.removeEventListener("animationcancel",d),e.removeEventListener("animationend",d)}}else m("ANIMATION_END")},[e,m]),{isPresent:["mounted","unmountSuspended"].includes(u),ref:i.useCallback(c=>{o.current=c?getComputedStyle(c):null,n(c)},[])}}function N(t){return(t==null?void 0:t.animationName)||"none"}function x(t){var o,r;let e=(o=Object.getOwnPropertyDescriptor(t.props,"ref"))==null?void 0:o.get,n=e&&"isReactWarning"in e&&e.isReactWarning;return n?t.ref:(e=(r=Object.getOwnPropertyDescriptor(t,"ref"))==null?void 0:r.get,n=e&&"isReactWarning"in e&&e.isReactWarning,n?t.props.ref:t.props.ref||t.ref)}export{z as P,V as a,b,k as c,B as d,q as u};
